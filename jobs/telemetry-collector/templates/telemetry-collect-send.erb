#!/usr/bin/env bash

set -e

# Add krb5 binaries to PATH for SPNEGO support (if available)
if [ -d /var/vcap/packages/krb5/bin ]; then
  export PATH="/var/vcap/packages/krb5/bin:${PATH}"
fi

rm -f /var/vcap/data/telemetry-collector/*.tar
chown -R vcap:vcap /var/vcap/jobs/telemetry-collector/config/
COLLECTOR_BIN=/var/vcap/packages/telemetry-cli/telemetry-cli-linux

# Update value usage function
create_or_update_options() {
    local file_path="${1}"
    local op_data_key="operational-data-only:"

    local strings_to_remove=(
      "cf-api-url"
      "usage-service-url"
      "usage-service-client-id"
      "usage-service-client-secret"
      "usage-service-insecure-skip-tls-verify"
      "usage-service-timeout"
    )

    # We only need to process the file if the
    # data-collection-multi-select-options property
    # exists. If it doesn't, that indicates that the
    # tile that set these properties is from the 1.x
    # line and didn't allow users to choose operational_data
    # without ceip_data.
    if ! grep -q "data-collection-multi-select-options:" "${file_path}"; then
        return
    fi

    local multiselect_value=$(grep "data-collection-multi-select-options:" "${file_path}" | awk '{$1=""; print $0}' | tr -d ' ')

    # If only ceip is selected, remove the usage service variables
    if [ "${multiselect_value}" == '["ceip_data"]' ]; then
        for string in "${strings_to_remove[@]}"; do
            sed -i.bak "/${string}/d" "${file_path}"
        done
    fi

    # If tas-installed-selector == 'Disabled', remove the usage service variables
    local tas_installed_value=$(grep "tas-installed-selector:" "${file_path}" | awk '{$1=""; print $0}' | tr -d ' ')

    if [ "${tas_installed_value}" == 'Disabled' ]; then
        for string in "${strings_to_remove[@]}"; do
            sed -i.bak "/${string}/d" "${file_path}"
        done
    fi

    # Append `https://app-usage.` to usage-service-url if it
    # has a value and doesn't already start with `http`.
    local usage_service_value=$(grep "usage-service-url:" "${file_path}" | awk -F': ' '{print $2}' | tr -d ' ')
    if [[ -n "${usage_service_value}" && ! "${usage_service_value}" =~ ^http ]]; then
        local updated_value="https://app-usage.${usage_service_value}"

        sed -i.bak "s~usage-service-url: ${usage_service_value}~usage-service-url: ${updated_value}~" "${file_path}"
    fi


    # Set correct value for operational-data-only (either true or false).
    # Create this property if it doesn't already exist.
    if ! grep -q "${op_data_key}" "${file_path}"; then
        if [ "${multiselect_value}" == '["operational_data"]' ]; then
          echo "${op_data_key} true" >> "${file_path}"
        else
          echo "${op_data_key} false" >> "${file_path}"
        fi
    else
        if [ "${multiselect_value}" == '["operational_data"]' ]; then
            sed -i.bak "/${op_data_key}/{s/false/true/;}" "${file_path}"
        else
            sed -i.bak "/${op_data_key}/{s/true/false/;}" "${file_path}"
        fi
    fi
    
    # Clean up backup files created by sed
    rm -f "${file_path}.bak"
}

# Set SPNEGO enabled flag based on whether all three credentials are provided
set_spnego_enabled_flag() {
    local file_path="${1}"
    local spnego_key="spnego-enabled:"
    
    # Get SPNEGO credentials from BOSH properties
    # Use Base64 encoding to handle ALL password characters including single quotes
    local proxy_username='<%= p('telemetry.proxy_settings.proxy_username') %>'
    local proxy_password_b64='<%= Base64.strict_encode64(p('telemetry.proxy_settings.proxy_password')) %>'
    local proxy_password=$(echo "${proxy_password_b64}" | base64 -d)
    local proxy_domain='<%= p('telemetry.proxy_settings.proxy_domain') %>'
    
    # Determine if SPNEGO is enabled
    # All three credentials must be non-empty
    local spnego_enabled="false"
    if [[ -n "${proxy_username}" && -n "${proxy_password}" && -n "${proxy_domain}" ]]; then
        spnego_enabled="true"
    fi
    
    # Remove existing spnego-enabled line if present (for idempotency)
    sed -i.bak "/${spnego_key}/d" "${file_path}"
    
    # Append the spnego-enabled flag
    echo "${spnego_key} ${spnego_enabled}" >> "${file_path}"
    
    # Clean up backup files
    rm -f "${file_path}.bak"
}

# Config paths
pre_start_config="/var/vcap/jobs/telemetry-collector/config/pre-start-collect.yml"
config="/var/vcap/jobs/telemetry-collector/config/collect.yml"

# Check and update pre-start-collect.yml
create_or_update_options "${pre_start_config}"
set_spnego_enabled_flag "${pre_start_config}"

# Check and update collect.yml
create_or_update_options "${config}"
set_spnego_enabled_flag "${config}"

# Calculate SPNEGO enabled flag for CLI
proxy_username='<%= p('telemetry.proxy_settings.proxy_username') %>'
proxy_password_b64='<%= Base64.strict_encode64(p('telemetry.proxy_settings.proxy_password')) %>'
proxy_password=$(echo "${proxy_password_b64}" | base64 -d)
proxy_domain='<%= p('telemetry.proxy_settings.proxy_domain') %>'

SPNEGO_ENABLED="false"
if [[ -n "${proxy_username}" && -n "${proxy_password}" && -n "${proxy_domain}" ]]; then
    SPNEGO_ENABLED="true"
fi

# Always collect data (must succeed)
"${COLLECTOR_BIN}" collect --config "${1}" --tile-spnego-enabled="${SPNEGO_ENABLED}"
collect_exit_code="${?}"

if [ "${collect_exit_code}" -ne 0 ]; then
  echo "ERROR: Telemetry data collection failed with exit code ${collect_exit_code}" >&2
  exit "${collect_exit_code}"
fi

# Find all TAR files created by collection
# When --split-tar-by-data-type is enabled, there will be multiple TAR files
# (e.g., FoundationDetails_<timestamp>_operational.tar and FoundationDetails_<timestamp>_ceip.tar)
#
# Use null-terminated output (-print0) to safely handle filenames with special characters
TAR_FILES=()
while IFS= read -r -d '' file; do
  TAR_FILES+=("$file")
done < <(find /var/vcap/data/telemetry-collector -name "*.tar" -type f -print0 2>/dev/null)
TAR_COUNT="${#TAR_FILES[@]}"

# Verify at least one tarball exists after successful collection
if [ "${TAR_COUNT}" -eq 0 ]; then
  printf "ERROR: No tarball found after collection\n" >&2
  exit 1
fi

# Verify all tarballs exist
for TAR_FILE in "${TAR_FILES[@]}"; do
  if [ ! -f "${TAR_FILE}" ]; then
    printf "ERROR: Tarball does not exist: %s\n" "${TAR_FILE}" >&2
    exit 1
  fi
done

# Only attempt to send if not in audit mode
audit_mode='<%= p('audit_mode') %>'
printf "DEBUG: Found %d tarball(s)\n" "${TAR_COUNT}" >&2
for TAR_FILE in "${TAR_FILES[@]}"; do
  printf "DEBUG:   - %s\n" "${TAR_FILE}" >&2
done
printf "DEBUG: Audit mode: %s\n" "${audit_mode}" >&2
if [ "${audit_mode}" != "true" ]; then
  export no_proxy='<%= p('telemetry.proxy_settings.no_proxy') %>'
  export http_proxy='<%= p('telemetry.proxy_settings.http_proxy') %>'
  export https_proxy='<%= p('telemetry.proxy_settings.https_proxy') %>'
  
  # Get SPNEGO credentials from BOSH properties
  # Use Base64 encoding to handle ALL password characters including single quotes
  SPNEGO_USERNAME='<%= p('telemetry.proxy_settings.proxy_username') %>'
  SPNEGO_PASSWORD_B64='<%= Base64.strict_encode64(p('telemetry.proxy_settings.proxy_password')) %>'
  SPNEGO_PASSWORD=$(echo "${SPNEGO_PASSWORD_B64}" | base64 -d)
  SPNEGO_DOMAIN='<%= p('telemetry.proxy_settings.proxy_domain') %>'
  
  # Export SPNEGO credentials as environment variables if all three are provided
  if [[ -n "${SPNEGO_USERNAME}" && -n "${SPNEGO_PASSWORD}" && -n "${SPNEGO_DOMAIN}" ]]; then
    # Set unique credential cache to prevent race conditions between concurrent runs
    # PID ($$) guarantees uniqueness; timestamp aids debugging
    export KRB5CCNAME="/tmp/krb5cc_collector_$$_$(date +%s)"
    export PROXY_USERNAME="${SPNEGO_USERNAME}"
    export PROXY_PASSWORD="${SPNEGO_PASSWORD}"
    export PROXY_DOMAIN="${SPNEGO_DOMAIN}"
    printf "INFO: SPNEGO proxy authentication enabled for user %s@%s\n" "${SPNEGO_USERNAME}" "${SPNEGO_DOMAIN}" >&2
    
    # Validate SPNEGO system requirements (kinit, curl with GSS-API)
    if ! command -v kinit >/dev/null 2>&1; then
      printf "ERROR: SPNEGO configured but kinit not found in PATH\n" >&2
      printf "ERROR: This is unusual for Ubuntu stemcells and indicates a potential issue\n" >&2
      # Don't fail deployment - log and continue
    elif ! curl -V 2>&1 | grep -qi "gss\|kerberos"; then
      printf "ERROR: SPNEGO configured but curl lacks GSS-API support\n" >&2
      printf "ERROR: This is unusual for Ubuntu stemcells and indicates a potential issue\n" >&2
      # Don't fail deployment - log and continue
    else
      printf "INFO: SPNEGO system requirements validated\n" >&2
    fi
  fi
  
  # Track send results for all TAR files
  send_failures=0
  send_successes=0
  
  # Loop through and send each TAR file
  for TAR_FILE in "${TAR_FILES[@]}"; do
    printf "DEBUG: Sending tarball: %s\n" "${TAR_FILE}" >&2
    
    # Attempt send but don't fail if it errors
    set +e
    send_output=$("${COLLECTOR_BIN}" send --path "${TAR_FILE}" --api-key <%= p('telemetry.api_key') %> <% if_p('telemetry.endpoint_override') do |endpoint_override| %> --override-telemetry-endpoint <%= endpoint_override %> <% end %> 2>&1)
    send_exit_code="${?}"
    set -e
    
    if [ "${send_exit_code}" -ne 0 ]; then
      send_failures=$((send_failures + 1))
      
      # Log structured error for monitoring
      timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
      log_file="/var/vcap/sys/log/telemetry-collector/send-failures.log"
      
      # Ensure log directory exists
      mkdir -p "$(dirname "${log_file}")"
      
      # Classify error type based on output
      if printf '%s' "${send_output}" | grep -qi "unauthorized\|not authorized\|401"; then
        error_type="CUSTOMER_CONFIG_ERROR"
        error_msg="API key is invalid or expired"
      elif printf '%s' "${send_output}" | grep -qi "kinit.*not found\|curl.*not found\|gss-api"; then
        error_type="SYSTEM_REQUIREMENTS_ERROR"
        error_msg="SPNEGO system requirements not met - kinit or curl with GSS-API missing"
      elif printf '%s' "${send_output}" | grep -qi "connection refused\|timeout\|503\|502\|504"; then
        error_type="MIDDLEWARE_PIPELINE_ERROR"
        error_msg="Telemetry infrastructure is temporarily unavailable"
      elif printf '%s' "${send_output}" | grep -qi "proxy.*authentication\|407\|spnego\|kerberos"; then
        error_type="PROXY_AUTH_ERROR"
        error_msg="Proxy authentication failed - check proxy credentials"
      else
        error_type="UNKNOWN_ERROR"
        error_msg="Telemetry send failed"
      fi
      
      # Log structured error - escape special characters in output for valid JSON
      # Using jq if available, otherwise basic escaping
      if command -v jq >/dev/null 2>&1; then
        escaped_output=$(printf '%s' "${send_output}" | jq -Rs '.')
        escaped_tar_file=$(printf '%s' "${TAR_FILE}" | jq -Rs '.')
        printf '{"timestamp":"%s","error_type":"%s","message":"%s","exit_code":%d,"tar_file":%s,"output":%s}\n' \
          "${timestamp}" "${error_type}" "${error_msg}" "${send_exit_code}" "${escaped_tar_file}" "${escaped_output}" >> "${log_file}"
      else
        # Basic escaping: replace backslashes, quotes, and control characters
        escaped_output=$(printf '%s' "${send_output}" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g' | tr '\n' ' ')
        escaped_tar_file=$(printf '%s' "${TAR_FILE}" | sed 's/\\/\\\\/g; s/"/\\"/g')
        printf '{"timestamp":"%s","error_type":"%s","message":"%s","exit_code":%d,"tar_file":"%s","output":"%s"}\n' \
          "${timestamp}" "${error_type}" "${error_msg}" "${send_exit_code}" "${escaped_tar_file}" "${escaped_output}" >> "${log_file}"
      fi
      
      # Also log human-readable warning
      printf "WARNING: Telemetry send failed for %s - data collected successfully and will be retried by cron job\n" "${TAR_FILE}" >&2
      printf "  Error type: %s\n" "${error_type}" >&2
      printf "  Details: %s\n" "${error_msg}" >&2
    else
      send_successes=$((send_successes + 1))
      
      # Log successful send
      timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
      log_file="/var/vcap/sys/log/telemetry-collector/send-success.log"
      
      # Ensure log directory exists
      mkdir -p "$(dirname "${log_file}")"
      
      # Escape tar_file for JSON
      if command -v jq >/dev/null 2>&1; then
        escaped_tar_file=$(printf '%s' "${TAR_FILE}" | jq -Rs '.')
        printf '{"timestamp":"%s","status":"success","message":"Telemetry sent successfully during startup","tar_file":%s}\n' \
          "${timestamp}" "${escaped_tar_file}" >> "${log_file}"
      else
        escaped_tar_file=$(printf '%s' "${TAR_FILE}" | sed 's/\\/\\\\/g; s/"/\\"/g')
        printf '{"timestamp":"%s","status":"success","message":"Telemetry sent successfully during startup","tar_file":"%s"}\n' \
          "${timestamp}" "${escaped_tar_file}" >> "${log_file}"
      fi
    fi
  done
  
  # Clean up SPNEGO credentials from environment
  unset PROXY_USERNAME PROXY_PASSWORD PROXY_DOMAIN SPNEGO_USERNAME SPNEGO_PASSWORD SPNEGO_DOMAIN
  
  # Log summary if multiple TAR files were processed
  if [ "${TAR_COUNT}" -gt 1 ]; then
    printf "INFO: Sent %d of %d TAR file(s) successfully\n" "${send_successes}" "${TAR_COUNT}" >&2
    if [ "${send_failures}" -gt 0 ]; then
      printf "WARNING: %d of %d TAR file(s) failed to send\n" "${send_failures}" "${TAR_COUNT}" >&2
    fi
  fi
else
  printf "INFO: Audit mode enabled - data collected but not sent\n" >&2
fi

# Always exit successfully if we reach here
exit 0
